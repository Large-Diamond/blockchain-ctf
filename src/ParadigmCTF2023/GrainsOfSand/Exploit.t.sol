// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {Challenge} from "./challenge/Challenge.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Exploit, ITokenStore, IToken} from "./Exploit.sol";

contract ExploitTest is Test {
    address playerAddr = makeAddr("player");
    Challenge challenge;
    ITokenStore tokenStore;
    IToken token;

    function setUp() public {
        vm.createSelectFork("mainnet", 18437825);
        vm.deal(playerAddr, 1000 ether);
        challenge = new Challenge();
        tokenStore = ITokenStore(0x1cE7AE555139c5EF5A57CC8d814a867ee6Ee33D8);
        token = IToken(0xC937f5027D47250Fa2Df8CbF21F6F88E98817845);
    }

    function testInvestigate() public view {
        console2.log("== balance ==");
        console2.log("ether balance  ", playerAddr.balance / 1e18);
        console2.log("TOTAL SUPPLY   ", token.totalSupply());
        console2.log("INITIAL BALANCE", token.balanceOf(address(tokenStore)));
        console2.log("REQUIRED DIFF  ", uint256(11111e8));

        console2.log("== token store ==");
        console2.log("deprecated     ", tokenStore.deprecated());
        console2.log("successor      ", tokenStore.successor());

        console2.log("== token ==");
        console2.log("libAddress     ", token.libAddress());
        console2.log("databaseAddress", token.databaseAddress());
        console2.log("depositsAddress", token.depositsAddress());
        console2.log("forkAddress    ", token.forkAddress());
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);

        Exploit exploit = new Exploit(address(challenge));
        exploit.exploit1{value: 2 ether}();

        while (!challenge.isSolved()) {
            exploit.exploit2();
        }

        vm.stopPrank();

        assertTrue(challenge.isSolved());
    }
}
